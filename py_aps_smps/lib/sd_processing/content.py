#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Apr 28 11:37:34 2021

Modify and extend size distribution datasets

@author: tobias.schorr@kit.edu
"""
import warnings
import numpy as np


def calc_dS_from_dN_for_sphere(dN, dp):
    return dN * 4 * np.pi * (dp / 2)**2
    

def calc_dm_from_dN_for_sphere(dN, dp, density):
    return dN * 4 / 3 * np.pi * (dp / 2)**3 * density


def calc_dXdlogd_from_dX(dX, channel_resolution=None, bins_lower=None, bins_upper=None):
    """Normalize bin values on channel width"""
    
    def calc_dXdlogd_from_dX_with_channel_resolution(dX, channel_resolution):
        return dX * channel_resolution
    
    def calc_dXdlogd_from_dX_with_bin_boundaries(dX, bins_lower, bins_upper):
        return dX / (np.log10(bins_upper) - np.log10(bins_lower))
    
    if (channel_resolution is not None) and (bins_lower is None) and (bins_upper is None):
        dXdlogd = calc_dXdlogd_from_dX_with_channel_resolution(dX, channel_resolution)
    elif (bins_lower is not None) and (bins_upper is not None):
        dXdlogd = calc_dXdlogd_from_dX_with_bin_boundaries(dX, bins_lower, bins_upper)
    else:
        raise ValueError("`channel_resolution` or lower + upper bin boundaries must be given.")
    
    return dXdlogd


# %%

def correct_extend_truncate_raw_sd_data(raw_sd_data, device_name, channel_resolution, density=1, shapefactor=1, temp_K=None, dp_min=None, dp_max=None, dn_correction_factor=1):
    """Correct and extend raw sd table generated by read_raw_sd()
    
    See also:
    --------
        * py_aps_smps.lib.io.sd.read_raw_sd()
    """
    from py_aps_smps.lib.sd_processing.structure import calc_bin_boundaries
    
    def apply_temperature_correction_on_dn(dN, temp_K, dn_correction_factor):
        return dN * 298 / temp_K
    
    def apply_correction_factor_on_dn(dn, dn_correction_factor):
        return dn * dn_correction_factor
    
    def transform_diameter_mobility_equivalent_to_equivalent_sphere(diameter, shapefactor):
        return diameter / shapefactor
    
    def transform_diameter_aerodynamic_to_equivalent_sphere(diameter, density, shapefactor):
        return diameter / np.sqrt(density) * np.sqrt(shapefactor)
    
    sd_data = raw_sd_data.copy()
    
    # if device specific diameter thresholds are not set, use default values
    if dp_min is None:
        if 'smps' in device_name:
            dp_min = 0.01
        elif 'aps' in device_name:
            dp_min = 0.8
    if dp_max is None:
        if 'smps' in device_name:
            dp_max = 0.8
        elif 'aps' in device_name:
            dp_max = 20
    
    # transform diameter thresholds to equivalent sphere diameter
    if 'smps' in device_name:
        dpes_min, dpes_max = map(transform_diameter_mobility_equivalent_to_equivalent_sphere, (dp_min, dp_max), (shapefactor, shapefactor))
    elif 'aps' in device_name:
        dpes_min, dpes_max = map(transform_diameter_aerodynamic_to_equivalent_sphere, [dp_min, dp_max], [density, density], [shapefactor, shapefactor])
    
    # derive eq. sphere diameter for size dist.
    if 'smps' in device_name:
        sd_data['dpes'] = transform_diameter_mobility_equivalent_to_equivalent_sphere(sd_data['dp'], shapefactor)
    elif 'aps' in device_name:
        sd_data['dpes'] = transform_diameter_aerodynamic_to_equivalent_sphere(sd_data['dp'], density, shapefactor)
    
    # add bin boundaries
    sd_data['dpes_lower'], sd_data['dpes_upper'] = calc_bin_boundaries(sd_data['dpes'], channel_resolution)
    
    # apply corrections on dN
    sd_data['dn'] = apply_correction_factor_on_dn(sd_data['dn'], dn_correction_factor)
    if temp_K:
        sd_data['dn'] = apply_temperature_correction_on_dn(sd_data['dn'], temp_K, dn_correction_factor)
    else:
        warnings.warn("Temperature not specified, SD could not be corrected w.r.t. temperature", UserWarning)
    
    # following IDL code: replace nan with 0
    sd_data['dn'] = sd_data['dn'].fillna(0)
        
    # derive related size distributions from dN
    sd_data['ds'] = calc_dS_from_dN_for_sphere(sd_data['dn'], sd_data['dpes'])
    sd_data['dm'] = calc_dm_from_dN_for_sphere(sd_data['dn'], sd_data['dpes'], density)
    for dX in ['dn', 'ds', 'dm']:
        sd_data[dX + 'dlogd'] = calc_dXdlogd_from_dX(sd_data[dX], channel_resolution=channel_resolution, bins_lower=None, bins_upper=None)
    
    # define boundaries for valid diameters and truncate dataset
    mask_valid_sd_data = (sd_data['dpes'] >= dpes_min) & (sd_data['dpes'] <= dpes_max)

    return sd_data[mask_valid_sd_data]
