# -*- coding: utf-8 -*-
"""
Created on Tue Feb 18 12:40:00 2020

Main function for a full size distribution analysis.
The function analyze_sd() wraps import, processing, concatenation, correction
and fitting of size distributions to provide a proper user frontend.

@author: tobias.schorr@kit.edu
         based on code from barbara.bertozzi@kit.edu
"""
import os

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

from py_aps_smps.lib.io.sql import sql_query
from py_aps_smps.lib.io.sd import read_sd_parameters
from py_aps_smps.lib.io.sd import read_raw_sd
from py_aps_smps.lib.sd_processing.content import correct_extend_truncate_raw_sd_data
from py_aps_smps.lib.sd_processing.content import calc_dXdlogd_from_dX
from py_aps_smps.lib.sd_processing.content import calc_dS_from_dN_for_sphere
from py_aps_smps.lib.sd_processing.content import calc_dm_from_dN_for_sphere
from py_aps_smps.lib.io.ambient_conditions import get_temperature_at_sd_exp
from py_aps_smps.lib.io.ambient_conditions import get_cpc_concentration_at_sd_exp
from py_aps_smps.lib.sd_processing.structure import combine_SMPS_APS_sd
from py_aps_smps.lib.sd_processing.structure import get_channel_resolution
from py_aps_smps.lib.sd_processing.structure import calc_bin_boundaries
from py_aps_smps.lib.sd_processing.distributions import lognormal, bilognormal


# %% Main function: Analyze size distribution

def analyze_sd(campaign, exp_num, density, shapefactor,
               chamber=None,
               smps_name='smps2', smps_id=None, smps_cf=1,
               aps_name='aps3', aps_id=None, aps_cf=1,
               merge_smps_aps_overlap=True,
               interpolate_smps_aps_gap=True,
               smooth=False,
               interpolate_to=None,
               custom_dataset=None,
               custom_timestamp=None,
               custom_temperature=None,
               custom_cn_cpc=None,
               n_modes=1, s_modes=1, m_modes=1,
               n1_p0=[0.5, 1.5, 300],
               n2_p0=[0.5, 1.3, 200],
               s1_p0=[0.1, 2.0, 100],
               s2_p0=[0.5, 1.5, 2000],
               m1_p0=[0.1, 2.0, 5],
               m2_p0=[0.5, 1.5, 500],
               smps_dp_min=0.01,
               smps_dp_max=0.8,
               aps_dp_min=0.8,
               aps_dp_max=20,
               fit=True, save_data=False,
               plot=True, save_plot=False,
               verbose=True):
    """Analyze size distributions of SMPS/APS measurements.

    Parameters
    ----------
    campaign : str
        Campaign name.
    exp_num : int or str
        Number of the experiment for which the size distribution was measured.
    density : numeric
        Density of the aerosol, in g cm⁻³.
    shapefactor : numeric
        Shape factor of the aerosol; 1 for a sphere.
    chamber : str, optional
        'aida' or 'naua'.
        The default is None.
    smps_name : str, optional
        Specify which SMPS was used.
        The default is 'smps2'.
    smps_id : int or str, optional
        ID of the SMPS measurement.
        The default is None.
    smps_cf : int or float, optional
        Correction factor for the number concentration determined by SMPS.
        The default is 1.
    aps_name : str, optional
        Specifiy which APS was used.
        The default is 'aps3'.
    aps_id : int or str, optional
        ID of the APS measurement.
        The default is None.
    aps_cf : int or float, optional
        Correction factor for the number concentration determined by APS.
        The default is 1.
    merge_smps_aps_overlap : bool, optional
        Decide if overlap of APS and SMPS range should be merged.
        The smaller SMPS bins will be merged into the bigger APS bins.
        The default is True.
    interpolate_smps_aps_gap : bool, optional
        Decide if gap between APS and SMPS range should be interpolated.
        The default is True.
    smooth: str or bool, optional
        Decide if smoothing you be applied on (a part of) the dataset.
        You can choose between 'aps', 'smps', and 'both'/'all'/True.
        The default is False.
    interpolate_to : None or np.ndarray, optional
        Pass a custom diameter grid as a new base of the size distribution.
        It can be generated by `np.logspace(dim_start, dim_end, num_points)`
        The default is None.
    custom_dataset : None or pd.DataFrame(), optional
        A custom dataset can be passed. This enables the SD analysis of
        preprocessed datasets (e.g. sum or average of different SDs).
        Columns for diameter 'dpes' and binned number concentration 'dn' are obligatory.
        The columns 'dndlogd', 'ds', 'dsdlogd', 'dm', 'dmdlogd', 'dpes_lower' and 'dpes_upper' are optional and  will be generated if not given.
        The default is None.
    custom_timestamp : None or datetime.datetime/pd.Timestamp, optional
        If `custom_dataset` is defined this timestamp is used.
        The default is None.
    custom_temperature : float, optional
        Custom temperature in K. If not specified, temperature is taken from logger.
        The default is None.
    custom_cn_cpc : float, optional
        Custom number concentration in cm-3.
        If not specified, CPC number concentration is taken from logger.
        The default is None.
    n_modes : int, optional
        Number of modes in the number size distribution to be fitted.
        The default is 1.
    s_modes : int, optional
        Number of modes in the surface size distribution to be fitted.
        The default is 1.
    m_modes : int, optional
        Number of modes in the mass size distribution to be fitted.
        The default is 1.
    n1_p0 : list, optional
        Start parameters for the fit of the first mode in the number size distribution.
        A list of [median_diameter, sigma, total_number] with diameter in µm and total_number in cm⁻³.
        The default is [0.5, 1.5, 300].
    n2_p0 : list, optional
        Start parameters for the fit of the second mode in the number size distribution.
        A list of [median_diameter, sigma, total_number] with diameter in µm and total_number in cm⁻³.
        The default is [0.5, 1.3, 200].
    s1_p0 : list, optional
        Start parameters for the fit of the first mode in the surface size distribution.
        A list of [median_diameter, sigma, total_surface] with diameter in µm and total_surface in µm² cm⁻³.
        The default is [0.1, 2.0, 100].
    s2_p0 : list, optional
        Start parameters for the fit of the second mode in the surface size distribution.
        A list of [median_diameter, sigma, total_surface] with diameter in µm and total_surface in µm² cm⁻³.
        The default is [0.5, 1.5, 2000].
    m1_p0 : list, optional
        Start parameters for the fit of the first mode in the mass size distribution.
        A list of [median_diameter, sigma, total_mass] with diameter in µm and total_mass in µg m⁻³.
        The default is [0.1, 2.0, 5].
    m2_p0 : list, optional
        Start parameters for the fit of the second mode in the mass size distribution.
        A list of [median_diameter, sigma, total_mass] with diameter in µm and total_mass in µg m⁻³.
        The default is [0.5, 1.5, 500].
    smps_dp_min : int/float, optional
        Lower mobility diameter theshold for SMPS data, in µm.
        The default is 0.01.
    smps_dp_max : int/float, optional
        Upper mobility diameter theshold for SMPS data, in µm.
        The default is 0.8.
    aps_dp_min : int/float, optional
        Lower aerodynamic diameter theshold for APS data, in µm.
        The default is 0.8.
    aps_dp_max : int/float, optional
        Upper aerodynamic diameter theshold for APS data, in µm.
        The default is 20.
    fit : bool, optional
        Decide if fit should be applied on the size distribution.
        The default is True.
    save_data : bool or str, optional
        Decide if SD data should be saved.
        If you enter a string it is treated as the saving directory.
        The default is True.
    plot : bool, optional
        Decide if plots will be generated.
        The default is True.
    save_plot : bool, optional
        Decide if plots should be saved.
        The default is True.

    Returns
    -------
    (tot, num, surf, mass) : Tuple
        Returns a tuple with data and metadata.
        The metadata contains
        
        tot : pd.DataFrame()
            Contains the full size distribution dataset with all columns.
        num : dict
            Contains metadata for the number size distribution.
        surf : dict
            Contains metadata for the surface size distribution.
        mass : dict
            Contains metadata for the mass size distribution.
    """
    exp_num = str(exp_num).zfill(2)  # reformat variable exp_num to str
    
    if custom_dataset is not None:
        if verbose:
            print("INFO: You defined a custom_dataset.\nThe given information \
            on campaign and experiment number will be ignored and no APS/SMPS \
            information from the database will be queried!")
        
        tot = custom_dataset
        
        # define variables in case of a custom dataset
        tot['flag'] = 'custom'
        trel = 0  # relative seconds from expansion
        cn_CPC = None
        
        if custom_timestamp:
            t_sd = pd.Timestamp.now()  # timestamp of sd measurement
        else:
            t_sd = custom_timestamp
        
        # construct columns to match aps/smps dataset columns:
        if ('dpes_lower' or 'dpes_upper') not in tot.columns:
            channel_res = len(tot['dpes']) / (np.log10(tot['dpes'].max()) - np.log10(tot['dpes'].min()))
            tot['dpes_lower'], tot['dpes_upper'] = calc_bin_boundaries(tot['dpes'], channel_res)
        
        if 'ds' not in tot.columns:
            tot['ds'] = calc_dS_from_dN_for_sphere(tot.dn, tot.dpes)
        if 'dm' not in tot.columns:
            tot['dm'] = calc_dm_from_dN_for_sphere(tot.dn, tot.dpes, density)
            
        for prop in ['dn', 'ds', 'dm']:
            if (prop + 'dlogd') not in tot.columns:
                tot[prop + 'dlogd'] = calc_dXdlogd_from_dX(tot[prop], bins_lower=tot['dpes_lower'], bins_upper=tot['dpes_upper'])
        
    elif custom_dataset is None:  # let the user chose between the available size distributions
    
        def read_sd_exp_information_from_database(campaign, exp_num, device_name, verbose=False):
            sd_db_entries = sql_query('device_data', f'SELECT * FROM {device_name}_parameter WHERE kampagne = "{campaign}" AND expnum = {str(exp_num)}', verbose=verbose)
            if verbose:
                print(f"Found {len(sd_db_entries)} {device_name} measurements in the database for {campaign}#{str(exp_num).zfill(2)}:")
                print('\n', sd_db_entries[['geraet', 'id', 'zeitpunkt', 'trel_sec']])
            return sd_db_entries
    
        def user_select_sd_exp_from_list(sd_db_entries, device_name):
            index = input(f"Choose the index of the {device_name.upper()} measurement that should be analysed (0 - {len(sd_db_entries) - 1}): ")
            return index
        
        if smps_id is None:
            smps_db = read_sd_exp_information_from_database(campaign, exp_num, smps_name, verbose=verbose)
            smps_index = user_select_sd_exp_from_list(smps_db, smps_name)
            smps_id = str(smps_db.loc[int(smps_index), 'id'])
        if aps_id is None:
            aps_db = read_sd_exp_information_from_database(campaign, exp_num, aps_name, verbose=verbose)
            aps_index = user_select_sd_exp_from_list(aps_db, aps_name)
            aps_id = str(aps_db.loc[int(aps_index), 'id'])
        
        # define key parameters with help of smps data (could also based on aps data)
        smps_parameters = read_sd_parameters(smps_name, smps_id)
        aps_parameters = read_sd_parameters(aps_name, aps_id)
               
        t_sd = smps_parameters['timestamp']  # exact time of SD measurement
        trel = smps_parameters['trel_sec']  # relative time of SD measurement from chamber expansion
        if chamber is None and (aps_parameters['messort'] == smps_parameters['messort']):
            chamber = smps_parameters['messort'].lower()
            
        if custom_temperature:
            temp_K = custom_temperature
        else:
            temp_K = get_temperature_at_sd_exp(campaign, exp_num, chamber, trel)
            
        if custom_cn_cpc:
            cn_CPC = custom_cn_cpc
        else:
            cn_CPC = get_cpc_concentration_at_sd_exp(campaign, exp_num, chamber, trel, verbose=verbose)
        
        # get combined size distribution from simultaneous APS/SMPS measurement
        sd_aps_raw = read_raw_sd(aps_name, aps_id)
        sd_smps_raw = read_raw_sd(smps_name, smps_id)
        
        sd_aps = correct_extend_truncate_raw_sd_data(sd_aps_raw, aps_name, aps_parameters['channel_res'], density, shapefactor, temp_K, dp_min=aps_dp_min, dp_max=aps_dp_max, dn_correction_factor=aps_cf)
        sd_smps = correct_extend_truncate_raw_sd_data(sd_smps_raw, smps_name, smps_parameters['channel_res'], density, shapefactor, temp_K, dp_min=smps_dp_min, dp_max=smps_dp_max, dn_correction_factor=smps_cf)
        
        if smooth:
            def smooth_dataset(dn, window=5, min_periods=1, win_type='triang'):
                dn_smoothed = dn.rolling(window=window, min_periods=min_periods, win_type=win_type, center=True).mean()
                return dn_smoothed

            if smooth is True:
                smooth = 'all'
            elif smooth not in ['aps', 'smps', 'all', 'both']:
                raise ValueError("You can only pass the following arguments for keyword `smooth` in analyze_sd():\n"
                                 "'aps', 'smps', 'all', 'both'.\n"
                                 f"Instead you passed '{smooth}'.")
               
            if smooth in ['aps', 'all', 'both']:
                sd_aps['dn'] = smooth_dataset(sd_aps['dn'])
                sd_aps.loc[:, 'dndlogd'] = calc_dXdlogd_from_dX(sd_aps.loc[:, 'dn'], bins_lower=sd_aps.loc[:, 'dpes_lower'], bins_upper=sd_aps.loc[:, 'dpes_upper'])
                sd_aps.loc[:, 'ds'] = calc_dS_from_dN_for_sphere(sd_aps.loc[:, 'dn'], sd_aps.loc[:, 'dpes'])
                sd_aps.loc[:, 'dsdlogd'] = calc_dXdlogd_from_dX(sd_aps.loc[:, 'ds'], bins_lower=sd_aps.loc[:, 'dpes_lower'], bins_upper=sd_aps.loc[:, 'dpes_upper'])
                sd_aps.loc[:, 'dm'] = calc_dm_from_dN_for_sphere(sd_aps.loc[:, 'dn'], sd_aps.loc[:, 'dpes'], density)
                sd_aps.loc[:, 'dmdlogd'] = calc_dXdlogd_from_dX(sd_aps.loc[:, 'dm'], bins_lower=sd_aps.loc[:, 'dpes_lower'], bins_upper=sd_aps.loc[:, 'dpes_upper'])
                
            if smooth in ['smps', 'all', 'both']:
                sd_smps['dn'] = smooth_dataset(sd_smps['dn'])
                sd_smps.loc[:, 'dndlogd'] = calc_dXdlogd_from_dX(sd_smps.loc[:, 'dn'], bins_lower=sd_smps.loc[:, 'dpes_lower'], bins_upper=sd_smps.loc[:, 'dpes_upper'])
                sd_smps.loc[:, 'ds'] = calc_dS_from_dN_for_sphere(sd_smps.loc[:, 'dn'], sd_smps.loc[:, 'dpes'])
                sd_smps.loc[:, 'dsdlogd'] = calc_dXdlogd_from_dX(sd_smps.loc[:, 'ds'], bins_lower=sd_smps.loc[:, 'dpes_lower'], bins_upper=sd_smps.loc[:, 'dpes_upper'])
                sd_smps.loc[:, 'dm'] = calc_dm_from_dN_for_sphere(sd_smps.loc[:, 'dn'], sd_smps.loc[:, 'dpes'], density)
                sd_smps.loc[:, 'dmdlogd'] = calc_dXdlogd_from_dX(sd_smps.loc[:, 'dm'], bins_lower=sd_smps.loc[:, 'dpes_lower'], bins_upper=sd_smps.loc[:, 'dpes_upper'])
        
        tot = combine_SMPS_APS_sd(sd_aps, sd_smps, merge_overlap=merge_smps_aps_overlap, interpolate_gap=interpolate_smps_aps_gap, verbose=verbose)
        
        # adjust flag if smoothed
        if smooth:
            if smooth in ['aps', 'all', 'both']:
                mask = tot.flag == 'aps'
                tot.loc[mask, 'flag'] = 'aps_smoothed'
            if smooth in ['smps', 'all', 'both']:
                mask = tot.flag == 'smps'
                tot.loc[mask, 'flag'] = 'smps_smoothed'

        if merge_smps_aps_overlap or interpolate_smps_aps_gap or smooth:
            modified_bins = ~tot.flag.str.contains('aps|smps', regex=True)  # match merged or interpolated bins
            # tot.loc[modified_bins, 'dndlogd'] = calc_dXdlogd_from_dX(tot.loc[modified_bins, 'dn'], bins_lower=tot.loc[modified_bins, 'dpes_lower'], bins_upper=tot.loc[modified_bins, 'dpes_upper'])
            tot.loc[modified_bins, 'ds'] = calc_dS_from_dN_for_sphere(tot.loc[modified_bins, 'dn'], tot.loc[modified_bins, 'dpes'])
            tot.loc[modified_bins, 'dsdlogd'] = calc_dXdlogd_from_dX(tot.loc[modified_bins, 'ds'], bins_lower=tot.loc[modified_bins, 'dpes_lower'], bins_upper=tot.loc[modified_bins, 'dpes_upper'])
            tot.loc[modified_bins, 'dm'] = calc_dm_from_dN_for_sphere(tot.loc[modified_bins, 'dn'], tot.loc[modified_bins, 'dpes'], density)
            tot.loc[modified_bins, 'dmdlogd'] = calc_dXdlogd_from_dX(tot.loc[modified_bins, 'dm'], bins_lower=tot.loc[modified_bins, 'dpes_lower'], bins_upper=tot.loc[modified_bins, 'dpes_upper'])
        
    if interpolate_to is not None:
        assert type(interpolate_to) in (list, np.ndarray, pd.Series, pd.DataFrame, pd.Index)
        tot_interp = pd.DataFrame()
        tot_interp['dpes'] = interpolate_to
        tot_interp_channel_resolution = get_channel_resolution(tot_interp, 'dpes')
        tot_interp['dpes_lower'], tot_interp['dpes_upper'] = calc_bin_boundaries(tot_interp['dpes'], tot_interp_channel_resolution)
        
        tot_interp['dndlogd'] = np.interp(x=interpolate_to, xp=tot['dpes'], fp=tot['dndlogd'], left=0, right=0)
        tot_interp['dn'] = tot_interp['dndlogd'] * (tot_interp['dpes_upper'] - tot_interp['dpes_lower'])
        
        tot_interp['ds'] = calc_dS_from_dN_for_sphere(tot_interp['dn'], tot_interp['dpes'])
        tot_interp['dsdlogd'] = calc_dXdlogd_from_dX(tot_interp['ds'], bins_lower=tot_interp['dpes_lower'], bins_upper=tot_interp['dpes_upper'])
        tot_interp['dm'] = calc_dm_from_dN_for_sphere(tot_interp['dn'], tot_interp['dpes'], density)
        tot_interp['dmdlogd'] = calc_dXdlogd_from_dX(tot_interp['dm'], bins_lower=tot_interp['dpes_lower'], bins_upper=tot_interp['dpes_upper'])
        
        tot_interp['flag'] = 'interpolated'
        
        tot = tot_interp
        
    if save_data:
        if isinstance(save_data, str):
            data_dir = save_data
        elif isinstance(save_data, bool):
            data_dir = os.path.join('./', 'output', campaign, 'DataSets')
        
        if not os.path.isdir(data_dir):
            os.makedirs(data_dir)
        
        fmt = '%Y%m%d-%H%M'
        filename = f"SD_{t_sd.strftime(fmt)}_{campaign}_{str(exp_num).zfill(2)}_{chamber.upper()}_{trel}_{round(density, 2)}_{round(shapefactor, 2)}.csv"
        file_path = os.path.join(data_dir, filename)
        tot.to_csv(file_path)
        
        if verbose:
            print("INFO: Saved size distribution data to %s." % file_path)
    
    # %% Plot size distribution
    
    # for code iteration: create similar dictionaries for number/surface/mass
    num, surf, mass = {}, {}, {}
    
    num['name'] = 'number'
    num['shortname'] = 'N'
    num['unit'] = 'cm$^{-3}$'
    num['total'] = np.trapz(tot.dropna().dndlogd, np.log10(tot.dropna().dpes))
    num['textstr_total_exp'] = 'N$_{total}^{exp}$ = %.1f %s' % (num['total'], num['unit'])
    num['sd_var_name'] = 'dndlogd'
    num['fit_color'] = 'blue'
    if fit:
        num['modes'] = n_modes
        num['fit_params1'] = n1_p0
        num['fit_params2'] = n2_p0
        
    surf['name'] = 'surface'
    surf['shortname'] = 'S'
    surf['unit'] = 'µm$^2$ cm$^{-3}$'
    surf['total'] = np.trapz(tot.dropna().dsdlogd, np.log10(tot.dropna().dpes))
    surf['textstr_total_exp'] = 'S$_{total}^{exp}$ = %.1f %s' % (surf['total'], surf['unit'])
    surf['sd_var_name'] = 'dsdlogd'
    surf['fit_color'] = 'green'
    if fit:
        surf['modes'] = s_modes
        surf['fit_params1'] = s1_p0
        surf['fit_params2'] = s2_p0
        
    mass['name'] = 'mass'
    mass['shortname'] = 'm'
    mass['unit'] = 'µg m$^{-3}$'
    mass['total'] = np.trapz(tot.dropna().dmdlogd, np.log10(tot.dropna().dpes))
    mass['textstr_total_exp'] = 'm$_{total}^{exp}$ = %.1f %s' % (mass['total'], mass['unit'])
    mass['sd_var_name'] = 'dmdlogd'
    mass['fit_color'] = 'red'
    if fit:
        mass['modes'] = m_modes
        mass['fit_params1'] = m1_p0
        mass['fit_params2'] = m2_p0
        
    if fit:
        def fit_sd_lognormal(Dp, dXdlogDp, n_modes, p0):
            """Wrapper function for lognormal fits"""
            from scipy.optimize import curve_fit
            
            if n_modes == 1:
                fit_function = lognormal
            elif n_modes == 2:
                fit_function = bilognormal
            else:
                raise ValueError("Maximum 2 lognormal modes to be fitted are implemented.")
            
            popt, cov = curve_fit(fit_function, Dp, dXdlogDp, p0)
            return (popt, cov)
        
        def fit_sd(sd_type, verbose=False):
            if sd_type['modes'] == 1:
                p0 = sd_type['fit_params1']
            elif sd_type['modes'] == 2:
                p0 = sd_type['fit_params1'] + sd_type['fit_params2']
            
            try:
                popt, cov = fit_sd_lognormal(Dp=tot.dropna()['dpes'], dXdlogDp=tot.dropna()[sd_type['sd_var_name']], n_modes=sd_type['modes'], p0=p0)
            except RuntimeError as err:
                raise RuntimeError(f"Fit of {sd_type['name']} size distribution failed. You should maybe try other start parameters. \n"
                                   "For an estimate run the function `analyze_sd` with the options 'fit=False' and 'plot=True'. \n"
                                   "You can also try the 'smooth' keyword on APS/SMPS/both to achieve a better fit. \n"
                                   f"Exact error message:\n'{err}'")
            
            if sd_type['modes'] == 1:
                [sd_type['fit_mu'], sd_type['fit_sigma'], sd_type['fit_total']] = popt
                sd_type['textstr_total_fit'] = f"{sd_type['shortname']}" + "$_{total}^{fit}$ " + f"= {round(sd_type['fit_total'], 2)} {sd_type['unit']}"
            elif sd_type['modes'] == 2:
                [sd_type['fit_mu'], sd_type['fit_sigma'], sd_type['fit_total'], sd_type['fit_mu2'], sd_type['fit_sigma2'], sd_type['fit_total2']] = popt
                sd_type['textstr_total_fit'] = f"{sd_type['shortname']}" + "$_{total}^{fit}$ " + f"= {round(sd_type['fit_total'] + sd_type['fit_total2'], 2)} {sd_type['unit']}"

            if verbose:
                print('v' * 72 + '\n'
                      f"Fit parameters for lognormal {sd_type['name']} size distribution\n"
                      
                      "\nFirst mode:\n"
                      f"D_mean = {sd_type['fit_mu']}\n"
                      f"sigma = {sd_type['fit_sigma']}\n"
                      f"{sd_type['shortname']}_total_fit = {sd_type['fit_total']}")
                if sd_type['modes'] == 2:
                    print("\nSecond mode:\n"
                          f"D_mean = {sd_type['fit_mu2']} \n"
                          f"sigma = {sd_type['fit_sigma2']} \n"
                          f"{sd_type['shortname']}_total_fit = {sd_type['fit_total2']}")
            
                print("\nCovariance matrix:")
                print(cov)
                print('^' * 72)
            return sd_type
        
        for sd_type in [num, surf, mass]:
            sd_type = fit_sd(sd_type, verbose=verbose)
                
    # %% Generate a plot for number/surface/mass size distribution, respectively
    
    if plot:
        plot_colors = dict()
        plot_colors['aps'] = 'bisque'
        plot_colors['smps'] = 'khaki'
        plot_colors['aps_smoothed'] = 'bisque'
        plot_colors['smps_smoothed'] = 'khaki'
        plot_colors['merged'] = 'goldenrod'
        plot_colors['interpolated'] = 'goldenrod'
    
    if plot:
        for i, sd_type in enumerate([num, surf, mass]):
            
            fig = plt.figure(dpi=200)
            if custom_dataset is None:
                fig.suptitle("%s#%s (%1i s), $\\varrho$ = %1.2f g cm$^{-3}$,  $ \\chi $ = %1.1f"
                             % (campaign, exp_num, int(trel), density, shapefactor))
            else:
                fig.suptitle("Custom dataset, $\\varrho$ = %1.2f g cm$^{-3}$,  $ \\chi $ = %1.1f"
                             % (density, shapefactor))
            
            ax = fig.add_subplot(111)
            ax.set_xscale('log')
            ax.set_xlabel('$D_p$ [$\\mu m$]')
            ax.set_ylabel('d' + sd_type['shortname'] + '/dlog(D$_p$) [' + sd_type['unit'] + ']')
            ax.grid(which='major', ls='--', color='grey')
            ax.grid(which='minor', ls=':', color='lightgrey')
            ax.set_yscale('log')
            ax.set_xscale('log')
            ax.set_xlim([0.01, 20])
            
            if custom_dataset is None:
                for flag in tot.flag.unique():
                    data = tot[tot.flag == flag]
                    ax.bar(data['dpes'], data[sd_type['sd_var_name']],
                           width=(data['dpes_upper'] - data['dpes_lower']),
                           color=plot_colors[flag], edgecolor='k', lw=0.5, alpha=0.7,
                           label=flag)
            
            elif custom_dataset is not None:
                ax.bar(tot['dpes'][tot.flag == 'custom'],
                       tot[sd_type['sd_var_name']][tot.flag == 'custom'],
                       width=(tot['dpes_upper'] - tot['dpes_lower'])[tot.flag == 'custom'],
                       color='lightgrey', edgecolor='k', lw=0.5, alpha=0.7,
                       label='custom dataset')
            
            # plot fitted curves
            if fit:
                if sd_type['modes'] == 1:
                    ax.loglog(tot['dpes'],
                              lognormal(tot['dpes'], sd_type['fit_mu'], sd_type['fit_sigma'], sd_type['fit_total']),
                              label='Fit',
                              color=sd_type['fit_color'],
                              linewidth=3)
                    
                elif sd_type['modes'] == 2:
                    ax.loglog(tot['dpes'],
                              bilognormal(tot['dpes'], sd_type['fit_mu'], sd_type['fit_sigma'], sd_type['fit_total'], sd_type['fit_mu2'], sd_type['fit_sigma2'], sd_type['fit_total2']),
                              label='Fit',
                              color=sd_type['fit_color'],
                              linewidth=3)
                    
                    ax.loglog(tot['dpes'],
                              lognormal(tot['dpes'], sd_type['fit_mu'], sd_type['fit_sigma'], sd_type['fit_total']),
                              label='First mode',
                              color='cyan',
                              linewidth=1)
                    ax.loglog(tot['dpes'],
                              lognormal(tot['dpes'], sd_type['fit_mu2'], sd_type['fit_sigma2'], sd_type['fit_total2']),
                              label='Second mode',
                              color='darkturquoise',
                              linewidth=1)
                    
            ax.set_ylim(bottom=1 * 10**(-(i + 1)))
            
            # create box with total number concentration
            props = dict(boxstyle='round', facecolor=sd_type['fit_color'], alpha=0.4)
            boxtext = sd_type['textstr_total_exp']
            if fit:
                boxtext += '\n' + sd_type['textstr_total_fit']
            if cn_CPC and sd_type['name'] == 'number':
                boxtext += "\n N$_{CPC}^{exp}$ = " + f"{round(cn_CPC, 1)}" + " cm$^{-3}$"
            fig.text(0.1, 0.9,
                     boxtext,
                     # fontsize=14,
                     verticalalignment='top',
                     bbox=props,
                     transform=ax.transAxes)
            
            ax.legend(loc=1)
            
            if save_plot:
                if isinstance(save_plot, str):
                    plot_dir = save_plot
                elif isinstance(save_plot, bool):
                    plot_dir = os.path.join('./', 'output', campaign, 'Plots')
                    
                if not os.path.isdir(plot_dir):
                    os.makedirs(plot_dir)
                
                fmt = '%Y%m%d-%H%M'
                plot_filename = f"SD_{t_sd.strftime(fmt)}_{campaign}_{str(exp_num).zfill(2)}_{chamber.upper()}_{trel}_{round(density, 2)}_{round(shapefactor, 2)}_{sd_type['shortname']}.png"
                plot_path = os.path.join(plot_dir, plot_filename)
                fig.savefig(plot_path, bbox_inches='tight', dpi=200)
                
                if verbose:
                    print("INFO: Saved plot on %s size distribution in %s" % (sd_type['name'], plot_path))
        
        # %% Create combined plot with all 3 size distributions (and fit functions)
    
    if plot:
        
        fig_all = plt.figure(figsize=(10, 12), dpi=200)
        
        if custom_dataset is not None:
            title_text = f"Custom dataset, $\\varrho$ = {round(density, 2)} " + " g cm$^{-3}$, $\\chi $ = " + f"{round(shapefactor, 2)}"
        elif custom_dataset is None:
            title_text = (f"{campaign}, Exp#{str(exp_num).zfill(2)} ({trel} s), {t_sd.strftime('%Y-%m-%d %H:%M')}\n"
                          f"$\\varrho$ = {round(density, 2)} " + "g cm$^{-3}$, $\\chi $ = " + f"{round(shapefactor, 2)}")
        
        fig_all.suptitle(title_text, fontsize='x-large')
        
        for i, sd_type in enumerate([num, surf, mass]):
            
            sd_type['plt_axis'] = fig_all.add_subplot(3, 1, i + 1)
            sd_type['plt_axis'].set_title('%s size distribution' % (sd_type['name'].capitalize()))
            sd_type['plt_axis'].set_ylabel('d' + sd_type['shortname'] + '/dlog(D$_p$) [' + sd_type['unit'] + ']')
            sd_type['plt_axis'].set_xlabel('D$_p$ [$\\mu m$]')
            sd_type['plt_axis'].grid(which='major', ls='--', color='grey')
            sd_type['plt_axis'].grid(which='minor', ls=':', color='lightgrey')
            sd_type['plt_axis'].set_yscale('log')
            sd_type['plt_axis'].set_xscale('log')
            sd_type['plt_axis'].set_xlim([0.01, 20])
            
            # Plot the number/surface/mass size distribution
            if custom_dataset is None:
                for flag in tot.flag.unique():
                    data = tot[tot.flag == flag]
                    sd_type['plt_axis'].bar(data['dpes'], data[sd_type['sd_var_name']],
                                            width=(data['dpes_upper'] - data['dpes_lower']),
                                            color=plot_colors[flag], edgecolor='k', lw=0.5, alpha=0.7,
                                            label=flag)
                                            
            elif custom_dataset is not None:
                sd_type['plt_axis'].bar(tot['dpes'][tot.flag == 'custom'],
                                        tot[sd_type['sd_var_name']][tot.flag == 'custom'],
                                        width=(tot['dpes_upper'] - tot['dpes_lower'])[tot.flag == 'custom'],
                                        color='lightgrey', edgecolor='k', lw=0.5, alpha=0.7,
                                        label='custom dataset')
            
            # plot fitted curves
            if fit:
                if sd_type['modes'] == 1:
                    sd_type['plt_axis'].loglog(tot['dpes'],
                                               lognormal(tot['dpes'], sd_type['fit_mu'], sd_type['fit_sigma'], sd_type['fit_total']),
                                               label='Fit',
                                               color=sd_type['fit_color'],
                                               linewidth=3)
                elif sd_type['modes'] == 2:
                    sd_type['plt_axis'].loglog(tot['dpes'],
                                               bilognormal(tot['dpes'], sd_type['fit_mu'], sd_type['fit_sigma'], sd_type['fit_total'], sd_type['fit_mu2'], sd_type['fit_sigma2'], sd_type['fit_total2']),
                                               label='Fit',
                                               color=sd_type['fit_color'],
                                               linewidth=3)
                    sd_type['plt_axis'].loglog(tot['dpes'],
                                               lognormal(tot['dpes'], sd_type['fit_mu'], sd_type['fit_sigma'], sd_type['fit_total']),
                                               label='First mode',
                                               color='cyan',
                                               linewidth=1)
                    sd_type['plt_axis'].loglog(tot['dpes'],
                                               lognormal(tot['dpes'], sd_type['fit_mu2'], sd_type['fit_sigma2'], sd_type['fit_total2']),
                                               label='Second mode',
                                               color='darkturquoise',
                                               linewidth=1)
            
            # plot box with info on experimental total number/surface/mass
            props = dict(boxstyle='round', facecolor=sd_type['fit_color'], alpha=0.4)
            boxtext = sd_type['textstr_total_exp']
            if fit:
                boxtext += '\n' + sd_type['textstr_total_fit']
            if cn_CPC and sd_type['name'] == 'number':
                boxtext += "\n N$_{CPC}^{exp}$ = " + f"{round(cn_CPC, 1)} " + "cm$^{-3}$"
            sd_type['plt_axis'].text(1.5e-2, sd_type['plt_axis'].get_ylim()[1] / 2,
                                     boxtext,
                                     fontsize=12,
                                     verticalalignment='top',
                                     horizontalalignment='left',
                                     bbox=props)
            
            sd_type['plt_axis'].set_ylim(bottom=1 * 10**(-(i + 1)))
        
        fig_all.axes[0].legend(loc=1)
        fig_all.tight_layout()
        
        if save_plot:
            if isinstance(save_plot, str):
                plot_dir = save_plot
            elif isinstance(save_plot, bool):
                plot_dir = os.path.join('./', 'output', campaign, 'Plots')
                
            if not os.path.isdir(plot_dir):
                os.makedirs(plot_dir)
            
            fmt = '%Y%m%d-%H%M'
            plot_filename = f"SD_{t_sd.strftime(fmt)}_{campaign}_{str(exp_num).zfill(2)}_{chamber.upper()}_{trel}_{round(density, 2)}_{round(shapefactor, 2)}_combined.png"
            plot_path = os.path.join(plot_dir, plot_filename)
            fig_all.savefig(plot_path, bbox_inches='tight', dpi=200)
    
    return (tot, num, surf, mass)
